CREATE TABLE CLIENTE (
	COD_CLI SERIAL PRIMARY KEY,
	NOME VARCHAR(30)
);

CREATE TABLE VENDA (
	COD_VENDA SERIAL PRIMARY KEY,
	COD_CLI INT REFERENCES CLIENTE(COD_CLI),
	VALOR_TOTAL FLOAT,
	DT_VENDA DATE
);

CREATE TABLE ITEM_VENDA (
	COD_PROD INT REFERENCES PRODUTO(COD_PROD),
	COD_VENDA INT REFERENCES VENDA(COD_VENDA),
	QUANT_VENDIDA INT
);

CREATE TABLE PRODUTO (
	COD_PROD SERIAL PRIMARY KEY,
	VALOR FLOAT,
	NOME VARCHAR(30),
	QUANT INT
);

CREATE TABLE COMBO (
	COD_PROD_COMBO INT NOT NULL REFERENCES PRODUTO(COD_PROD),
	QUANT INT,
	COD_PRODUTO_COMP INT NOT NULL REFERENCES PRODUTO(COD_PROD),
	PRIMARY KEY (COD_PROD_COMBO, COD_PRODUTO_COMP)
);

INSERT INTO CLIENTE(NOME) VALUES
('Alice'),
('Bruno'),
('Carla'),
('Diego');

INSERT INTO PRODUTO(VALOR,NOME,QUANT) VALUES
(10.50, 'Caneta Azul', 100),
(5.00,  'L√°pis Preto', 200),
(15.90, 'Caderno 100 folhas', 150),
(3.20,  'Borracha', 300),
(8.00,  'R√©gua 30cm', 180),
(14.00, 'Caneta + Lapis Preto', 100),
(34.90, 'Caderno + Caneta + Lapis', 100);

INSERT INTO VENDA(COD_CLI, VALOR_TOTAL, DT_VENDA) VALUES
(1, 41.90, '2025-05-10'),
(2, 13.20, '2025-05-11');

INSERT INTO ITEM_VENDA(COD_PROD, COD_VENDA, QUANT_VENDIDA) VALUES
(3, 1, 2),  -- 2 x Caderno 100 folhas (15.90)
(1, 1, 1),  -- 1 x Caneta Azul (10.50)
(5, 2, 1),  -- 1 x R√©gua 30cm (8.00)
(4, 2, 2);  -- 2 x Borracha (3.20)

INSERT INTO COMBO (cod_prod_combo, COD_PRODUTO_COMP, QUANT) VALUES 
(6, 3, 1),  -- 1x Caderno + 2x Caneta + 1x Lapis
(6, 1, 2),  -- 1x Caderno + 2x Caneta + 1x Lapis
(6, 2, 1),  -- 1x Caderno + 2x Caneta + 1x Lapis
(7, 1, 1),  -- 1x Caneta Azul + 2x Lapis Preto
(7, 2, 2);  -- 1x Caneta Azul + 2x Lapis Preto

-- üìå TRIGGERS (8 Quest√µes)
-- 1 - Crie uma trigger que impe√ßa que o valor de `quant` (estoque) de qualquer produto fique abaixo de zero ap√≥s uma atualiza√ß√£o.
CREATE OR REPLACE TRIGGER TRG_IMPEDIR_ESTOQUE
BEFORE UPDATE ON PRODUTO
FOR EACH ROW EXECUTE PROCEDURE TG_IMPEDE_ESTOQUE();

CREATE OR REPLACE FUNCTION TG_IMPEDE_ESTOQUE()
RETURNS TRIGGER AS $$
BEGIN 

IF (NEW.QUANT < 0) THEN
	RAISE EXCEPTION 'Um estoque de um produto n√£o pode ficar abaixo de zero.';
END IF;

RETURN NEW;
END;
$$
LANGUAGE PLPGSQL;

-- 2 - Implemente uma trigger que registre em uma tabela de auditoria (`AUDITORIA_PRECO`) sempre que o valor (`valor`) de um produto for alterado. Armazene: `cod_prod`, `valor_antigo`, `valor_novo`, `data_modificacao`.
CREATE TABLE AUDITORIA_PRECO (
	COD_PROD INT NOT NULL,
	VALOR_ANTIGO FLOAT,
	VALOR_NOVO FLOAT,
	DATA_MODIFICACAO TIMESTAMP
);

CREATE OR REPLACE TRIGGER TRG_REGISTRA_AUDITORIA
AFTER UPDATE ON PRODUTO
FOR EACH ROW EXECUTE PROCEDURE TG_REGISTRAR_AUDITORIA();

CREATE OR REPLACE FUNCTION TG_REGISTRAR_AUDITORIA()
RETURNS TRIGGER AS $$
BEGIN 

IF (NEW.VALOR <> OLD.VALOR) THEN
	INSERT INTO AUDITORIA_PRECO VALUES
	(NEW.COD_PROD, OLD.VALOR, NEW.VALOR, CURRENT_TIMESTAMP);
	RETURN NEW;

END IF;
END;
$$
LANGUAGE PLPGSQL;
	
-- 3 - Crie uma trigger que atualize automaticamente o `valor_total` da tabela `VENDA` sempre que um item for inserido ou alterado na tabela `ITEM_VENDA`.
CREATE OR REPLACE TRIGGER TRG_ATUALIZA_VALOR_TOTAL
AFTER INSERT OR UPDATE ON ITEM_VENDA
FOR EACH ROW EXECUTE PROCEDURE TG_ATUALIZAR_VALOR_TOTAL();

CREATE OR REPLACE FUNCTION TG_ATUALIZAR_VALOR_TOTAL()
RETURNS TRIGGER AS $$
BEGIN 

IF (NEW.VALOR_TOTAL <> OLD.VALOR_TOTAL) THEN
	UPDATE VENDA
	SET VALOR_TOTAL = NEW.VALOR_TOTAL;
	RETURN NEW;

END IF;
END;
$$
LANGUAGE PLPGSQL;

-- 4 - Implemente uma trigger que aplique 10% de desconto no valor do produto quando ele for um combo (ou seja, aparece como `cod_prod_combo` na tabela `COMBO`).
CREATE OR REPLACE TRIGGER TRG_APLICA_DESCONTO
BEFORE INSERT ON PRODUTO
FOR EACH ROW EXECUTE PROCEDURE TG_APLICAR_DESCONTO();

CREATE OR REPLACE FUNCTION TG_APLICAR_DESCONTO()
RETURNS TRIGGER AS $$
BEGIN 

IF EXISTS (SELECT * FROM COMBO WHERE COD_PROD_COMBO = NEW.COD_PROD) THEN
	NEW.COD_PROD = NEW.COD_PROD * 0.90;
	RETURN NEW;

END IF;
END;
$$
LANGUAGE PLPGSQL;