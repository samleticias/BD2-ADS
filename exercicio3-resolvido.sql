-- Fornecedor (cod_fornecedor, nome_fornenecdor, endereco_fornecedor)
CREATE TABLE FORNECEDOR (
	COD_FORNECEDOR SERIAL PRIMARY KEY,
	NOME_FORNECEDOR VARCHAR(30),
	ENDERECO_FORNECEDOR VARCHAR(30)
);

INSERT INTO FORNECEDOR (NOME_FORNECEDOR, ENDERECO_FORNECEDOR) VALUES 
('Fornecedor 1', 'Rua das Flores'),
('Fornecedor 2', 'Rua das Rosas'),
('Fornecedor 3', 'Rua das Margaridas');

-- Titulo (cod_titulo, descr_titulo)
CREATE TABLE TITULO (
	COD_TITULO SERIAL PRIMARY KEY,
	DESCR_LIVRO VARCHAR(30)
);

INSERT INTO TITULO (DESCR_LIVRO) VALUES 
('Vidas Secas'),
('São Bernardo'),
('Água Viva'),
('A hora da estrela');

-- Livro (cod_livro, cod_titulo, quant_estoque, valor_unitario)
CREATE TABLE LIVRO (
	COD_LIVRO SERIAL PRIMARY KEY,
	COD_TITULO INT REFERENCES TITULO(COD_TITULO),
	QUANT_ESTOQUE INT,
	VALOR_UNITARIO FLOAT
);

INSERT INTO LIVRO (COD_TITULO, QUANT_ESTOQUE, VALOR_UNITARIO) VALUES 
(1, 20, 30),
(2, 30, 40),
(3, 23, 30);

-- Pedido (cod_pedido, cod_fornecedor, data_pedido, valor_total_pedido, quant_itens_pedidos)
CREATE TABLE PEDIDO (
	COD_PEDIDO SERIAL PRIMARY KEY,
	COD_FORNECEDOR INT REFERENCES FORNECEDOR(COD_FORNECEDOR),
	DATA_PEDIDO TIMESTAMP,
	VALOR_TOTAL_PEDIDO FLOAT,
	QUANT_ITENS_PEDIDO INT
);

INSERT INTO PEDIDO (COD_FORNECEDOR, DATA_PEDIDO, VALOR_TOTAL_PEDIDO, QUANT_ITENS_PEDIDO) VALUES
(1, '2024-02-03', 200, 5),
(2, '2024-05-03', 500, 5),
(3, '2024-02-15', 200, 5);

-- Item_pedido (cod_livro, cod_pedido, quant_item, valor_total_item)
CREATE TABLE ITEM_PEDIDO (
    COD_LIVRO INT,
    COD_PEDIDO INT,
    QUANT_ITEM INT,
    VALOR_TOTAL_ITEM FLOAT,
    PRIMARY KEY (COD_LIVRO, COD_PEDIDO)
);

INSERT INTO ITEM_PEDIDO (COD_LIVRO, COD_PEDIDO, QUANT_ITEM, VALOR_TOTAL_ITEM) VALUES
(1, 2, 4, 200),
(3, 3, 4, 150),
(2, 3, 4, 200);

-- a) Mostre o nome dos fornecedores que venderam mais de X reais no mês de fevereiro de 2024.
SELECT NOME_FORNECEDOR FROM FORNECEDOR F JOIN PEDIDO P ON F.COD_FORNECEDOR = P.COD_FORNECEDOR WHERE DATA_PEDIDO
BETWEEN '2024-02-01' AND '2024-02-28' GROUP BY NOME_FORNECEDOR HAVING SUM(VALOR_TOTAL_PEDIDO) > 200;

-- b) Mostre o nome de um dos fornecedores que mais vendeu no mês de fevereiro de 2024.
SELECT NOME_FORNECEDOR, SUM(VALOR_TOTAL_PEDIDO) AS TOTAL_VENDIDO FROM FORNECEDOR F JOIN PEDIDO P ON 
F.COD_FORNECEDOR = P.COD_FORNECEDOR WHERE DATA_PEDIDO BETWEEN '2024-02-01' AND '2024-02-28' GROUP BY 
NOME_FORNECEDOR ORDER BY TOTAL_VENDIDO DESC LIMIT 1;

-- c) Qual o nome do(s) fornecedor(es) que mais vendeu(eram) no mês de fevereiro de 2024?
SELECT NOME_FORNECEDOR, SUM(VALOR_TOTAL_PEDIDO) AS TOTAL_VENDIDO FROM FORNECEDOR F JOIN PEDIDO P ON 
F.COD_FORNECEDOR = P.COD_FORNECEDOR WHERE DATA_PEDIDO BETWEEN '2024-02-01' AND '2024-02-28' GROUP BY 
NOME_FORNECEDOR ORDER BY TOTAL_VENDIDO DESC;

-- 3) Usando trigger, responda as questões a seguir.

-- a) Crie triggers que implementem todas essas restrições de chave primária, chave estrangeira
-- e valores não nulos nas tabelas Pedido e Item_pedido.

CREATE OR REPLACE FUNCTION CONTROLA_VALORES_PEDIDO()
RETURNS TRIGGER AS $$
BEGIN
	IF NEW.COD_PEDIDO <> OLD.COD_PEDIDO THEN
		RAISE EXCEPTION 'Não é permitido modificar o valor da chave primária COD_PEDIDO.';
	ELSIF NEW.COD_FORNECEDOR IS NULL THEN
		RAISE EXCEPTION 'O código do fornecedor não pode ser nulo.';
	ELSIF NEW.DATA_PEDIDO IS NULL THEN
		RAISE EXCEPTION 'A data do pedido não pode ser nula.';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_CONTROLA_VALORES_PEDIDO BEFORE INSERT ON PEDIDO FOR EACH ROW EXECUTE PROCEDURE 
CONTROLA_VALORES_PEDIDO();

INSERT INTO PEDIDO (COD_FORNECEDOR, DATA_PEDIDO, VALOR_TOTAL_PEDIDO, QUANT_ITENS_PEDIDO) VALUES
(NULL, '2024-02-03', 200, 5);

INSERT INTO PEDIDO (COD_FORNECEDOR, DATA_PEDIDO, VALOR_TOTAL_PEDIDO, QUANT_ITENS_PEDIDO) VALUES
(2, NULL, 200, 5);

CREATE FUNCTION IMPEDE_VALOR_NULO_ITENS()
RETURNS TRIGGER AS $$
BEGIN
	IF NEW.COD_PEDIDO IS NULL THEN
		RAISE EXCEPTION 'O código do pedido não pode ser nulo ao cadastrar o item do pedido.';
	ELSIF NEW.COD_LIVRO IS NULL THEN
		RAISE EXCEPTION 'O código do livro não pode ser nulo ao cadastrar o item do pedido.';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER IMPEDE_VALOR_NULO_CADASTRO_ITENS_PEDIDO BEFORE INSERT ON ITEM_PEDIDO FOR EACH ROW 
EXECUTE PROCEDURE IMPEDE_VALOR_NULO_ITENS();

INSERT INTO ITEM_PEDIDO (COD_PEDIDO, COD_LIVRO) VALUES
(NULL, 1); 

INSERT INTO ITEM_PEDIDO (COD_PEDIDO, COD_LIVRO) VALUES
(2, NULL);

CREATE FUNCTION IMPEDE_DUPLICIDADE_PK_PEDIDO()
RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT 1 FROM PEDIDO WHERE COD_PEDIDO = NEW.COD_PEDIDO) THEN
		RAISE EXCEPTION 'Já existe um pedido com a chave primária %', NEW.COD_PEDIDO;
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRG_IMPEDE_DUPLICIDADE_PK_PEDIDO BEFORE INSERT ON PEDIDO FOR EACH ROW EXECUTE PROCEDURE
IMPEDE_DUPLICIDADE_PK_PEDIDO();

INSERT INTO PEDIDO (COD_PEDIDO, COD_FORNECEDOR, DATA_PEDIDO, VALOR_TOTAL_PEDIDO) VALUES
(1, 1, '2025-04-01', 500);